{
	"Type of Integer on Mod (for CPP)": {
		"scope": "cpp",
		"prefix": "mint",
		"body": [
			"struct mint {",
			"\tll x;",
			"\tmint(ll x=0) : x((x%mod+mod)%mod) {}",
			"\tmint operator-() const { return mint(-x); }",
			"\tmint& operator+=(const mint a) {",
			"\t\tif ((x += a.x) >= mod) x -= mod;",
			"\t\treturn *this;",
			"\t}",
			"\tmint& operator-=(const mint a) {",
			"\t\tif ((x += mod-a.x) >= mod) x -= mod;",
			"\t\treturn *this;",
			"\t}",
			"\tmint& operator*=(const mint a) { (x *= a.x) %= mod; return *this;}",
			"\tmint operator+(const mint a) const { return mint(*this) += a;}",
			"\tmint operator-(const mint a) const { return mint(*this) -= a;}",
			"\tmint operator*(const mint a) const { return mint(*this) *= a;}",
			"\tmint pow(ll t) const {",
			"\t\tif (!t) return 1;",
			"\t\tmint a = pow(t>>1);",
			"\t\ta *= a;",
			"\t\tif (t&1) a *= *this;",
			"\t\treturn a;",
			"\t}",
			"\t/*",
			"\t// for prime mod",
			"\tmint inv() const { return pow(mod-2);}",
			"\tmint& operator/=(const mint a) { return *this *= a.inv();}",
			"\tmint operator/(const mint a) const { return mint(*this) /= a;}",
			"\t*/",
			"};",
			"istream& operator>>(istream& is, mint& a) { return is >> a.x; }",
			"ostream& operator<<(ostream& os, const mint& a) { return os << a.x; }",
			""
		],
		"description": "Class type for Integer on moduloes"
	},
	"Segment Tree": {
		"scope": "cpp",
		"prefix": "seg",
		"body": [
			"struct SegmentTree {",
				"\tint n;",
				"\tvector<int> dat;",
				"\tSegmentTree() { init(1); }",
				"\tSegmentTree(int n_) { init(n_); }",
				"\tvoid init(int n_) {",
					"\t\tn = 1;",
					"\t\twhile (n < n_) n *= 2;",
					"\t\tdat = vector<int>(2*n-1, (int)(1e9));",
				"\t}",
				"\tvoid update(int k, int a) {",
					"\t\tk += n-1;",
					"\t\tdat[k] = a;",
					"\t\twhile (k > 0) {",
						"\t\t\tk = (k-1) / 2;",
						"\t\t\tdat[k] = min(dat[k*2+1], dat[k*2+2]);",
					"\t\t}",
				"\t}",
				"\tint query(int a, int b, int k=0, int l=0, int r=-1) {",
					"\t\tif (r == -1) { r = n; k = 0; l = 0; }",
					"\t\tif (r<=a || b<=l) return (int)(1e9);",
					"\t\tif (a<=l && r<=b) return dat[k];",
					"\t\telse {",
						"\t\t\tint vl = query(a, b, k*2+1, l, (l+r)/2);",
						"\t\t\tint vr = query(a, b, k*2+2, (l+r)/2, r);",
						"\t\t\treturn min(vl, vr);",
					"\t\t}",
			"\t}",
			"};",
			""
		],
		"description": "Class library of Segment Tree"
	},
	"UnionFind": {
		"scope": "cpp",
		"prefix": "uf",
		"body": [
			"struct UnionFind {",
			"\tvector<int> d;",
			"\tUnionFind(int n=0) : d(n, -1) {}",
			"\tint find(int x) {",
			"\t\tif (d[x] < 0) return x;",
			"\t\treturn (d[x] = find(d[x]));",
			"\t}",
			"\tbool unite(int x, int y) {",
			"\t\tx = find(x); y = find(y);",
			"\t\tif (x == y) return false;",
			"\t\tif (d[x] > d[y]) swap(x, y);",
			"\t\td[x] += d[y];",
			"\t\td[y] = x;",
			"\t\treturn true;",
			"\t}",
			"\tbool same(int x, int y) { return (find(x) == find(y)); }",
			"\tint size(int x) { return -d[find(x)]; }",
			"};",
			""
		],
		"description": "UnionFind from atcoder-live"
	},
	"BIT": {
		"scope": "cpp",
		"prefix": "bit",
		"body": [
			"template<typename T>",
			"struct BIT {",
			"\tint n;",
			"\tvector<T> d;",
			"\tBIT(int n=0) : n(n), d(n+1) {}",
			"\tvoid add(int i, T x=1) {",
			"\t\tfor (i++; i<=n; i+=i&-i) {",
			"\t\t\td[i] += x;",
			"\t\t}",
			"\t}",
			"\tT sum(int i) {",
			"\t\tT x = 0;",
			"\t\tfor (i++; i; i-=i&-i) {",
			"\t\t\tx += d[i];",
			"\t\t}",
			"\t\treturn x;",
			"\t}",
			"\tT sum(int l, int r) {",
			"\t\treturn sum(r-1) - sum(l-1);",
			"\t}",
			"};",
			""
		],
		"description": "Binary Indexed Tree (Fenwick Tree) from atcoder-live"
	},
	"Combination": {
		"scope": "cpp",
		"prefix": "comb",
		"body": [
			"struct combination {",
			"\tvector<mint> fact, ifact;",
			"\tcombination(int n) : fact(n+1), ifact(n+1) {",
			"\t\tassert(n < mod);",
			"\t\tfact[0] = 1;",
			"\t\tfor (int i=1; i<=n; ++i) fact[i] = fact[i-1] * i;",
			"\t\tifact[n] = fact[n].inv();",
			"\t\tfor (int i=n; i>=1; --i) ifact[i-1] = ifact[i] * i;",
			"\t}",
			"\tmint operator()(int n, int k) {",
			"\t\tif (k<0 || k>n) return 0;",
			"\t\treturn (fact[n] * ifact[k] * ifact[n-k]);",
			"\t}",
			"};",
			""
		],
		"description": "Combination Mod Prime from atcoder-live"
	},
	"GCD/LCM": {
		"scope": "cpp",
		"prefix": "mygcd",
		"body": [
			"ll gcd(ll a, ll b) { return (b ? gcd(b, a%b) : a); }",
			"ll lcm(ll a, ll b) { return (a / gcd(a, b) * b); }",
			""
		],
		"description": "GCD and LCM Function from atcoder-live"
	},
	"Matrix": {
		"scope": "cpp",
		"prefix": "mat",
		"body": [
			"template<typename T>",
			"struct Matrix {",
			"\tint h, w;",
			"\tvector<vector<T>> d;",
			"\tMatrix() {}",
			"\tMatrix(int h, int w, T val=0) : h(h), w(w), d(h, vector<T>(w, val)) {}",
			"\tMatrix& unit() {",
			"\t\tassert(h == w);",
			"\t\trep(i, h) d[i][i] = 1;",
			"\t\treturn *this;",
			"\t}",
			"\tconst vector<T>& operator[](int i) const { return d[i]; }",
			"\tvector<T>& operator[](int i) { return d[i]; }",
			"\tMatrix operator*(const Matrix& a) const {",
			"\t\tassert(w == a.h);",
			"\t\tMatrix r(h, a.w);",
			"\t\trep(i, h) rep(k, w) rep(j, a.w) {",
			"\t\t\tr[i][j] += d[i][k] * a[k][j];",
			"\t\t}",
			"\t\treturn r;",
			"\t}",
			"\tMatrix pow(long long t) const {",
			"\t\tassert(h == w);",
			"\t\tif (!t) return Matrix(h, h).unit();",
			"\t\tif (t == 1) return *this;",
			"\t\tMatrix r = pow(t>>1);",
			"\t\tr = r * r;",
			"\t\tif (t&1) r = r * (*this);",
			"\t\treturn r;",
			"\t}",
			"};",
			""
		],
		"description": "Matrix Functions from atcoder-live"
	}
}
