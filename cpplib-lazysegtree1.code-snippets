{
	"LazySegmentTree(RMQ)": {
		"scope": "cpp",
		"prefix": "lazysegtree1",
		"body": [
			"template<typename T>",
			"class LazySegmentTree {",
				"\tT INF_ST;",
				"\tint n;",
				"\tvector<T> node, lazy;",
			"public:",
				"\tLazySegmentTree(int n_, T INF_ST_=numeric_limits<T>::max()) : LazySegmentTree(vector<T>(n_, INF_ST_), INF_ST_) {}",
				"\tLazySegmentTree(vector<T> v, T INF_ST_=numeric_limits<T>::max()) : INF_ST(INF_ST_) {",
					"\t\tint n_ = v.size();",
					"\t\tn = 1;",
					"\t\twhile (n < n_) n *= 2;",
					"\t\tnode.resize(n*2-1, INF_ST);",
					"\t\tlazy.resize(n*2-1, INF_ST);",
					"\t\tfor (int i=0; i<n_; ++i) node[n+i-1] = v[i];",
					"\t\tfor (int i=n-2; i>=0; --i) node[i] = min(node[i*2+1], node[i*2+2]);",
				"\t}",
				"\tvoid eval(int k, int l, int r) {",
					"\t\tif (lazy[k] != INF_ST) {",
						"\t\t\tnode[k] = lazy[k];",
						"\t\t\tif (r-l > 1) {",
							"\t\t\t\tlazy[k*2+1] = lazy[k*2+2] = lazy[k];",
						"\t\t\t}",
						"\t\t\tlazy[k] = INF_ST;",
					"\t\t}",
				"\t}",
				"\tvoid update(int a, int b, T x, int k=0, int l=0, int r=-1) {",
					"\t\tif (r == -1) r = n;",
					"\t\teval(k, l, r);",
					"\t\tif (b<=l || r<=a) return;",
					"\t\tif (a<=l && r<=b) {",
						"\t\t\tlazy[k] = x;",
						"\t\t\teval(k, l, r);",
					"\t\t}",
					"\t\telse {",
						"\t\t\tupdate(a, b, x, k*2+1, l, (l+r)/2);",
						"\t\t\tupdate(a, b, x, k*2+2, (l+r)/2, r);",
						"\t\t\tnode[k] = min(node[k*2+1], node[k*2+2]);",
					"\t\t}",
				"\t}",
				"\tT find(int a, int b, int k=0, int l=0, int r=-1) {",
					"\t\tif (r == -1) r = n;",
					"\t\teval(k, l, r);",
					"\t\tif (b<=l || r<=a) return INF_ST;",
					"\t\tif (a<=l && r<=b) return node[k];",
					"\t\tT vl = find(a, b, k*2+1, l, (l+r)/2);",
					"\t\tT vr = find(a, b, k*2+2, (l+r)/2, r);",
					"\t\treturn min(vl, vr);",
				"\t}",
			"};",
			""
		],
		"description": "Lazy segment tree class for RMQ"
	}
}
